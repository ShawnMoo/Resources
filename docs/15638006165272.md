# 内存管理相关


## iOS 上的内存分配
![-w1169](media/15638006165272/15638010128235.jpg)

stack:(栈区) 方法调用
heap:(堆区) 通过alloc等分配的对象
bss: 未初始化的全局变量
data: 已初始化的全局变量
text: 程序代码

#### 内存管理方案
1. TaggedPointer
2. NONPOINTER_ISA --非指针型内存管理方案
3. 散列表 --- 是一个复杂的数据结构，并且包括了引用计数表和弱引用表

#### NONPOINTER_ISA
在arm64架构下,64个bit位存储的内容如下:
![-w1272](media/15638006165272/15638071949943.jpg)
![-w1268](media/15638006165272/15638073489483.jpg)
 
 
####  散列表方式:
SideTables: 其实是一张hash表:
 ![-w1265](media/15638006165272/15638074532106.jpg)

* SideTable的数据结构:

![-w1180](media/15638006165272/15638075626161.jpg)


* 为什么不是一张SideTable,而是使用了多张SideTable?
因为一张表，并且牵扯到多线程安全问题，肯定是要加锁的，当要操作的对象个数较多的时候，存在效率问题
![-w1011](media/15638006165272/15638076922644.jpg)

为了解决效率问题, 苹果使用了分离锁的解决方法，用来解决效率问题
![-w1237](media/15638006165272/15638078380467.jpg)

* 分离锁如何快速分流?:
![-w1108](media/15638006165272/15638080055159.jpg)
![-w1034](media/15638006165272/15638080691282.jpg)

## 散列表实现内存管理

#### 散列表实现内存管理方式的数据结构
1. 自旋锁: Spinlock_t
2. 弱引用表: weak_table_t
3. 引用计数表: RefountMap
![-w882](media/15638006165272/15638880111687.jpg)
![-w1095](media/15638006165272/15638881674050.jpg)

size_t的结构:
![](media/15638006165272/15638883477092.jpg)

weak_table_t:
![](media/15638006165272/15638885303455.jpg)

#### ARC
ARC: 是LVVM跟Runtime相互协作的结果
ARC中禁止调用MRC中独有的方法：比如retain/release/retainCount/dealloc
ARC 新增了weak/stron 属性关键字

#### 引用计数管理

alloc 实现:
经过一些列调用,最终调用了C函数calloc
此时并没有设置引用计数为1

#### Retain 实现
![](media/15638006165272/15638929821372.jpg)
#### Release实现：
![-w1252](media/15638006165272/15638930902573.jpg)
#### RetainCount实现:
![](media/15638006165272/15638933766740.jpg)

#### dealloc的实现
* 对象释放判断机制:
只有当下面几个条件都为NO的时间才会释放:
![](media/15638006165272/15638940572914.jpg)
![](media/15638006165272/15638941012833.jpg)
![](media/15638006165272/15638943048206.jpg)
![](media/15638006165272/15638944376092.jpg)


## 弱引用管理

声明一个弱引用属性:
id __weak obj1 = obj; === 编译 ===> id obj1; objc_initWeak(&obj1,obj);
![](media/15638006165272/15646669835616.jpg)

一个被 __weak 修饰的对象指针，经过编译器编译后会变成objc_initWeak，然后经过一些的函数调用栈，最后会在weak_register_no_lock()这个函数中进行弱引用的添加，具体添加的位置是通过一个hash算法进行查找的，若查找到的位置已经有了当前对象所对应的弱引用数组，那么就会把新的弱引用变量添加那个数组中去，如果没有，就创建一个新的弱引用数组，并将新的弱引用变量添加到第0个位置。

## 弱引用管理 -- 清楚weak变量,同时设置指向为nil

在走dealloc 后会经过一些列的调用，最后走到weak_clear_no_lock函数
![](media/15638006165272/15649001092780.jpg)
![](media/15638006165272/15649052447318.jpg)


## 自动释放池 

#### AutoreleasePool的实现原理是怎样的
![](media/15638006165272/15649134198776.jpg)
![-w1009](media/15638006165272/15649136182244.jpg)
![](media/15638006165272/15649153879002.jpg)
 ![](media/15638006165272/15649158397780.jpg)
![](media/15638006165272/15649159678337.jpg)
![-w1065](media/15638006165272/15649160096376.jpg)
![](media/15638006165272/15649160972725.jpg)
![](media/15638006165272/15649169563656.jpg)
![](media/15638006165272/15649171201952.jpg)
#### autorelease的实现流程:
![](media/15638006165272/15649173540084.jpg)

![](media/15638006165272/15649175589208.jpg)
![](media/15638006165272/15649176109180.jpg)
![](media/15638006165272/15649176451357.jpg)
![](media/15638006165272/15649177802671.jpg)



## 循环引用
#### 如何破除循环引用？
1. 避免产生循环引用
2. 在合适的时机手动断环
#### 破除循环引用的具体方案
![](media/15638006165272/15649080976332.jpg)
![-w1109](media/15638006165272/15649081873232.jpg)
![-w1207](media/15638006165272/15649082055009.jpg)
![](media/15638006165272/15649082931173.jpg)


#### 破除循环引用的解决示例:
![](media/15638006165272/15649090075859.jpg)
